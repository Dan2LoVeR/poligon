Практическая работа 3. Определение косинусного расстояния между текстами

Практическая работа №3 посвящена решению задачи классификации текстов с помощью определения косинусного расстояния между ними.

Инструкция. Создайте копию блокнота и решите следующие задачи. Покажите решения преподавателю. Затем расшарьте блокнот и сдайте готовую работу через Sakai, раздел Задания.

Для подключения работы с файлами гугл-диска запустите следующий код :

from google.colab import drive
drive.mount('/content/drive')

Задание: Имеется файл sentences.txt, содержащий три типа предложений:

    Содержащие упоминания о кошках (содержат слова cat или cats).
    Посвященные описанию утилиты cat операционной системы Unix.
    Содержащие информацию о версиях операционных систем от Apple, по традиции называемых именами различных животных семейства кошачьих.

Задача состоит в том, чтобы выяснить наиболее близкие между собой предложения при помощи определения косинусного расстояния между ними.

# чтение файла (нужно прописать полный путь к своему файлу!)
file_obj = open('sentences.txt', 'r')
data_list = file_obj.readlines()
file_obj.close()

Теперь в переменной data_list находится все содержимое файла. Необходимо сделать из него массив words из всех слов, содержащихся в файле. В массиве не должно быть пустых элементов, каждое слово должно входить в массив ровно один раз, все слова должны быть приведены к нижнему регистру. Сортировать массив не нужно. Если все сделано правильно, количество элементов в массиве (len(words)) будет равно 254. Рекомендуется использовать регулярные выражения.

[] напишите программный код

Далее необходимо из массива создать словарь таким образом, чтобы слова стали ключами, а их номера в массиве — значениями элементов. Например, в массиве был нулевой элемент со значением in (arr[0]='in'), а в словаре D элемент с ключом 'in' будет иметь значение 0 (D['in']=0).

[] напишите программный код

Создайте целочисленную матрицу размера n на d, где d = 254 (размер исходного массива), а n = 22 — количество предложений в файле, и обнулите его. С помощью библиотеки numpy это можно сделать следующим образом:

import numpy as np
b = np.zeros((n,d),dtype=int)

Теперь нужно заполнить эту матрицу. Для этого нужно вернуться к исходному списку и повторить преобразование каждой строки в массив слов. После этого заполнить соответствующую строчку матрицы следующим образом. Для каждого слова выяснить из словаря D значение, ему соответствующее, и увеличить элемент матрицы из этой строки на единицу. Если слово встретилось в предложении более одного раза, то значение соответствующего элемента матрицы будет больше единицы, однако большая часть элементов каждой строки так и останется равной нулю.

После приведенных преобразований каждая строка матрицы соответствует вектору вхождений слов для соответствующей строки файла. Между этими векторами можно считать косинусное расстояние с помощью модуля spatial библиотеки scipy:

from scipy import spatial
# Пример вычисления косинусного расстояния между первыми двумя предложениями (векторами)
f0=b[0,:]
f1=b[1,:]
m1=spatial.distance.cosine(f0,f0)
m2=spatial.distance.cosine(f0,f1)
print(m1)
print(m2)

Определите косинусные расстояния попарно между всеми строками массива (желательно исключить проверки одинаковых строк). Найдите пять пар строк, наиболее близких друг к другу. Принадлежат ли они к одинаковым классам предложений?

[] напишите программный код